package inference

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"iter"

	"github.com/honganh1206/clue/message"
	"github.com/honganh1206/clue/prompts"
	"github.com/honganh1206/clue/tools"
	"google.golang.org/genai"
)

type GeminiModel struct {
	client    *genai.Client
	model     ModelVersion
	maxTokens int64
	// TODO: Fields for contents and tools during runtime?
}

func NewGeminiModel(client *genai.Client, model ModelVersion, maxTokens int64) *GeminiModel {
	return &GeminiModel{
		client:    client,
		model:     model,
		maxTokens: maxTokens,
	}
}

func (m *GeminiModel) Name() string {
	return GoogleModelName
}

func getGeminiModelName(model ModelVersion) string {
	return string(model)
}

func (m *GeminiModel) CompleteStream(ctx context.Context, msgs []*message.Message, tools []tools.ToolDefinition) (*message.Message, error) {
	contents := convertToGeminiContents(msgs)
	geminiTools, err := convertToGeminiTools(tools)
	if err != nil {
		return nil, fmt.Errorf("failed to convert tools: %w", err)
	}

	modelName := getGeminiModelName(m.model)

	sysPrompt := prompts.GeminiSystemPrompt()
	config := &genai.GenerateContentConfig{
		MaxOutputTokens:   int32(m.maxTokens),
		Tools:             geminiTools,
		SystemInstruction: genai.NewContentFromText(sysPrompt, genai.RoleUser),
	}

	iter := m.client.Models.GenerateContentStream(ctx, modelName, contents, config)

	response, err := streamGeminiResponse(iter)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func streamGeminiResponse(response iter.Seq2[*genai.GenerateContentResponse, error]) (*message.Message, error) {
	var fullText string
	var toolCalls []message.ContentBlockUnion
	var outputContents []*genai.Content

	msg := &message.Message{
		Role:    message.ModelRole,
		Content: make([]message.ContentBlockUnion, 0),
	}

	for chunk, err := range response {
		if err == io.EOF {
			break
		}

		if err != nil {
			return nil, err
		}

		// A candidate contains a content,
		// a content contains one or more parts
		if len(chunk.Candidates) == 0 || chunk.Candidates[0].Content == nil {
			return nil, fmt.Errorf("no content returned")
		}

		// First candidate is the most relevant response generated by the model,
		// so we only record the first candidate's content as the best one
		bestContent := chunk.Candidates[0].Content
		for _, p := range bestContent.Parts {
			if p.Text != "" {
				fmt.Print(p.Text)
				fullText += p.Text
			}
			if p.FunctionCall != nil {
				fc := p.FunctionCall
				inputBytes, err := json.Marshal(fc.Args)
				if err != nil {
					return nil, fmt.Errorf("failed to marshal function args: %w", err)
				}

				toolCall := message.NewToolUseContentBlock(
					fc.ID,
					fc.Name,
					inputBytes,
				)
				toolCalls = append(toolCalls, toolCall)
			}
		}

		outputContents = append(outputContents, bestContent)
	}

	if fullText != "" {
		msg.Content = append(msg.Content, message.NewTextContentBlock(fullText))
	}

	msg.Content = append(msg.Content, toolCalls...)

	return msg, nil
}

func convertToGeminiContents(msgs []*message.Message) []*genai.Content {
	contents := make([]*genai.Content, 0, len(msgs))

	for _, msg := range msgs {
		parts := convertToGeminiParts(msg.Content)
		if len(parts) == 0 {
			continue
		}

		content := &genai.Content{
			Role:  msg.Role,
			Parts: parts,
		}

		contents = append(contents, content)
	}

	return contents
}

func convertToGeminiParts(blocks []message.ContentBlockUnion) []*genai.Part {
	parts := make([]*genai.Part, 0, len(blocks))

	for _, b := range blocks {
		switch b.Type {
		case message.TextType:
			if b.OfTextBlock != nil {
				textContent := b.OfTextBlock.Text
				parts = append(parts, genai.NewPartFromText(textContent))
			}
		case message.ToolUseType:
			if b.OfToolUseBlock != nil {
				toolName := b.OfToolUseBlock.Name
				var args map[string]any

				err := json.Unmarshal(b.OfToolUseBlock.Input, &args)
				if err != nil {
					continue
				}

				parts = append(parts, genai.NewPartFromFunctionCall(toolName, args))
			}
		case message.ToolResultType:
			if b.OfToolResultBlock != nil {
				toolName := b.OfToolResultBlock.ToolName

				// Gemini NEEDS the content to be wrapped inside "result"
				response := map[string]any{"result": b.OfToolResultBlock.Content}

				parts = append(parts, genai.NewPartFromFunctionResponse(toolName, response))
			}
		}
	}

	return parts
}

func convertToGeminiTools(tools []tools.ToolDefinition) ([]*genai.Tool, error) {
	if len(tools) == 0 {
		return nil, nil
	}

	builtinTool := &genai.Tool{
		FunctionDeclarations: make([]*genai.FunctionDeclaration, 0, len(tools)),
	}

	for _, tool := range tools {
		geminiToolFuncDec, err := convertToGeminiFuncDeclaration(tool)
		if err != nil {
			return nil, err
		}
		builtinTool.FunctionDeclarations = append(builtinTool.FunctionDeclarations, geminiToolFuncDec)
	}

	return []*genai.Tool{builtinTool}, nil
}

func convertToGeminiFuncDeclaration(tool tools.ToolDefinition) (*genai.FunctionDeclaration, error) {
	schemaBytes, err := json.Marshal(tool.InputSchema)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal tool schema: %w", err)
	}

	var schema *genai.Schema
	if err := json.Unmarshal(schemaBytes, &schema); err != nil {
		return nil, fmt.Errorf("failed to unmarshal to Gemini schema: %w", err)
	}

	functionDecl := &genai.FunctionDeclaration{
		Name:        tool.Name,
		Description: tool.Description,
		Parameters:  schema,
	}

	return functionDecl, nil
}
